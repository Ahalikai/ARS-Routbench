[
    {
        "type": [
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - DVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - DVRPMPD: At Node [24], 10 units of goods are picked up, along with an additional amount calculated as 5 times the square root of the accumulated travel distance from the depot [0] to this node. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {24: 10} # values in user requirements\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    edge_weight = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        current_load = 0\n        total_distance = 0\n        previous_node = 0  # Start from the depot\n\n        for node in route:\n            total_distance += edge_weight[previous_node][node]\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                additional_pickup = 5 * (total_distance ** 0.5)\n                current_load -= pickup_nodes[node] + additional_pickup\n            else:\n                current_load += demand\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n            previous_node = node\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - MVRPMPD",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - MVRPMPD: Nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. At Node [24], I pick up 20 units of these goods and 10 units of original goods. Before pick up, it needs to check whether sufficient goods have been delivered. Both types of goods are stored separately, with a maximum load of 100 units for new goods on each route, and problem data excludes information about new goods.\n    extra_b_goods_nodes = {12: 70, 14: 80}  # Deliveries of Class B goods\n    pickup_node = 24\n    pickup_b_goods = 20\n    max_class_a_capacity = solution.problem_data[\"capacity\"]\n    max_class_b_capacity = 100\n    \n    for route in solution.routes:\n        current_load_class_a = 0\n        current_load_class_b = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            # Regular demand handling\n            if node == pickup_node:\n                if current_load_class_a - 10 < 0 or current_load_class_b - pickup_b_goods < 0:\n                    return False  # Insufficient goods to unload\n                current_load_class_a -= 10\n                current_load_class_b -= pickup_b_goods\n            else:\n                current_load_class_a += demand\n                if current_load_class_a > max_class_a_capacity:\n                    return False\n                    \n            # Handle Class B goods delivery\n            if node in extra_b_goods_nodes:\n                current_load_class_b += extra_b_goods_nodes[node]\n                if current_load_class_b > max_class_b_capacity:\n                    return False  # Exceeds Class B capacity\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Priority Constraint - VRPRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - HVRPMPD",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - HVRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    max_return_load = 100\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n    demand = solution.problem_data[\"demand\"]\n\n    low_load_routes_count = 0  # Counter for routes with total load < 100 units\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand[node] # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n        # Check if this route's final load is less than 100 units\n        if current_load < max_return_load:\n            low_load_routes_count += 1\n\n    # Ensure at least 3 routes have a final load less than 100 units\n    if low_load_routes_count < 3:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Pickup and Delivery Constraint - VRPMPD",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Pickup and Delivery Constraint - VRPMPD: At Node [24], 10 units of goods are picked up. Unlike delivery, visiting a pickup node reduces the vehicle's available capacity.\n    pickup_nodes = {\n        24: 10,  # [24] is a pickup node\n    }\n    vehicle_capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        current_load = 0\n\n        for node in route:\n            demand = solution.problem_data[\"demand\"][node]\n\n            if node in pickup_nodes:\n                current_load -= pickup_nodes[node] # When a pickup node is visited\n            else:\n                current_load += demand # When a delivery node is visited\n\n            # Check if the vehicle capacity is exceeded or negative after visiting this node\n            if current_load > vehicle_capacity or current_load < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - DCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - DCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, for node [19], its base demand is augmented by 5 times the square root of the accumulated travel distance from the depot [0] to that node.\n    edge_weight = solution.problem_data[\"edge_weight\"]\n    demand = solution.problem_data[\"demand\"]\n    capacity = solution.problem_data[\"capacity\"]\n\n    for route in solution.routes:\n        total_demand = 0\n        accumulated_distance = 0\n\n        prev_node = 0\n        for node in route:\n            # Calculate the distance from the previous node to the current node\n            accumulated_distance += edge_weight[prev_node][node]\n\n            # Adjust demand for node 19 based on accumulated distance\n            adjusted_demand = demand[node]\n            if node == 19:\n                adjusted_demand += 5 * (accumulated_distance ** 0.5)\n\n            total_demand += adjusted_demand\n\n            # If at any point the total demand exceeds the vehicle capacity, return False\n            if total_demand > capacity:\n                return False\n\n            prev_node = node  # Update the previous node for the next iteration\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - MCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - MCVRP: The total load of each route must not exceed the vehicle capacity. Additionally, nodes [12, 14] require deliveries of [70, 80] units of a new type of goods. The maximum load capacity for this type of goods on each route is 100 units, and problem data excludes information about new goods.\n    # Define additional constraints for Class B goods\n    class_b_nodes = {12: 70, 14: 80}  # Nodes with Class B goods and their respective demands\n    class_b_capacity = 100  # Maximum capacity for Class B goods per vehicle\n\n    for route in solution.routes:\n        total_demand = 0\n        total_class_b_demand = 0\n\n        for node in route:\n            # Add regular demand\n            total_demand += solution.problem_data[\"demand\"][node]\n\n            # Add Class B demand if the node is in the Class B list\n            if node in class_b_nodes:\n                total_class_b_demand += class_b_nodes[node]\n\n        # Check if total demand exceeds vehicle capacity\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n        # Check if Class B demand exceeds Class B capacity\n        if total_class_b_demand > class_b_capacity:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - HCVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - HCVRP: The total load of each route must not exceed the vehicle capacity. Specifically, there should be at least 3 routes where the total load is less than 100 units.\n    # Counter for routes with total demand less than 100\n    count_routes_less_than_100 = 0\n\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand < 100: \n            count_routes_less_than_100 += 1\n        elif total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    if count_routes_less_than_100 < 3:\n        return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - DVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - DVRPL: Each route must not exceed 200 units in length. The vehicle's remaining range decreases with each visit. After visiting node [17], the remaining range will be halved.\n    max_route_length = 200\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = 0\n        remaining_range = max_route_length\n\n        for idx in range(1, len(tour)):\n            remaining_range -= distances[tour[idx - 1]][tour[idx]]\n\n            if tour[idx] == 17:\n                remaining_range /= 2\n\n            if remaining_range < 0:\n                return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - RVRP",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - RVRP: After visiting node [17], the vehicle's remaining allowable travel distance for that route is reset to 150 units. At each node, the remaining driving distance cannot be negative.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        remaining_distance = max_route_length\n        \n        for idx in range(1, len(tour)):\n            travel_distance = distances[tour[idx - 1]][tour[idx]]\n            remaining_distance -= travel_distance\n\n            # Check if remaining distance is negative at any point\n            if remaining_distance < 0:\n                return False\n                \n            # Reset remaining distance upon visiting node 17\n            if tour[idx] == 17:\n                remaining_distance = max_route_length\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 8] must not be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - HVRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - HVRPL: Each route must not exceed 200 units in length, and at least three routes must have a total length of less than 150 units.\n    max_route_length = 200\n    short_route_threshold = 150\n    required_short_routes = 3\n    short_routes_count = 0\n    distances = solution.problem_data[\"edge_weight\"]\n    \n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx]][tour[idx + 1]] for idx in range(len(tour) - 1))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n        # Count the number of routes shorter than the threshold\n        if route_length < short_route_threshold:\n            short_routes_count += 1\n\n    # Ensure at least three routes are shorter than the threshold\n    if short_routes_count < required_short_routes:\n        return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 8] must not be on the same route. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - DVRPTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - DVRPTW: The arrival time at each node must meet its specified time window. For node [18], the service time dynamically increases by the amount of time from the start of its time window to the arrival time.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Adjust service time dynamically for node 18\n            if tour[idx] == 18:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]] + (current_time - tw_start)\n            else:\n                dynamic_service_time = solution.problem_data['service_time'][tour[idx]]\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += dynamic_service_time\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Priority Constraint - VRPMP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Priority Constraint - VRPMP: Nodes [7, 5, 3] are priority nodes with strictly decreasing priority levels: [7] (highest), [5], and [3] (lowest). Higher-priority nodes must be visited before lower-priority ones and other nodes.\n    # Define priority levels for nodes. Higher numbers mean higher priority.\n    priority_levels = {\n        7: 3,  # Highest priority\n        5: 2,\n        3: 1,   # Lowest priority\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - VRPSO"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPMTW",
            "Same Vehicle Constraint - CluVRP",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPMTW: The arrival time at each node must meet its specified time window. For node [4], in addition to its original time window, an additional time window of [900, 950] is also available.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if tour[idx] == 4:\n                # Node 4 has an additional available time window\n                tw_start_4, tw_end_4 = 900, 950\n                if not (tw_start <= current_time <= tw_end or tw_start_4 <= current_time <= tw_end_4):\n                    return False\n            else:\n                if current_time > tw_end:\n                    return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSO",
            "Priority Constraint - VRPRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23]. Node [8] is the priority node and must be one of the first three positions in at least one route.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSO: Nodes [13, 23] must be on the same route, and node [13] must be visited before node [23].\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            index_13 = route.index(13)\n            index_23 = route.index(23)\n            if index_13 < index_23:\n                break\n    else:\n        return False\n\n    # Priority Constraint - VRPRP: Node [8] is the priority node and must be one of the first three positions in at least one route.\n    priority_node = 8  # The priority node\n\n    # Iterate through all routes to find if the priority node appears in the first three positions\n    for route in solution.routes:\n        # Check if the priority node is in the first three positions of the route\n        if priority_node in route[:3]:\n            break  # Stop checking once we find a valid placement\n    else:\n        # If the loop completes without finding the priority node in the first three positions of any route\n        return False  # Constraint violated\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - HVRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0. Nodes [13, 23] must be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - HVRPTW: The arrival time at each node must meet its specified time window. Specifically, one route must have its start time is 300, while all other routes start with time 0.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n    flag2 = False\n    for route in solution.routes:\n        current_time = 300\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n    \n        flag1 = True\n        \n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n    \n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                flag1 = False\n                break  # Break out of the inner loop as soon as a violation is found\n    \n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n    \n        if flag1:  # Check if the entire route was feasible\n            flag2 = True\n            break  # Break out of the outer loop as soon as a feasible route is found\n    \n    if not flag2:\n        return False\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPILC",
            "Priority Constraint - VRP-dRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [7, 8] must not be on the same route. Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPILC: Nodes [7, 8] must not be on the same route.\n    for route in solution.routes:\n        if 7 in route and 8 in route:\n            return False\n\n    # Priority Constraint - VRP-dRP: Nodes [7, 5, 3] follow the d-relaxed priority rule with decreasing priority: [7] (highest), [5], and [3] (lowest). Each node can be visited within its level or one level later, but no lower-priority node can be visited more than one level early. Other nodes are non-priority.\n    # Define d-relaxed priority levels for specific nodes\n    priority_levels = {\n        7: 3,  # Priority level 3 (highest priority among these nodes)\n        5: 2,  # Priority level 2\n        3: 1,   # Priority level 1 (lowest priority among these nodes)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest possible priority level\n\n        for i, node in enumerate(route):\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # Check if the node violates the d-relaxed priority rule\n            if current_priority > last_priority + 1:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - CluVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - CluVRP: Nodes [7, 10] must be on the same route, and these nodes must be visited consecutively.\n    for route in solution.routes:\n        if 7 in route and 10 in route:\n            index_7 = route.index(7)\n            index_10 = route.index(10)\n            if abs(index_7 - index_10) != 1:\n                return False\n            break\n    else:\n        # If no route contains both nodes 7 and 10\n        return False\n\n    return True"
    },
    {
        "type": [
            "Vehicle Capacity Constraint - CVRP",
            "Distance Limit Constraint - VRPL",
            "Time Windows Constraint - VRPTW",
            "Same Vehicle Constraint - VRPSVC",
            "Priority Constraint - PVRP"
        ],
        "description": "The total load of each route must not exceed the vehicle capacity. Each route must not exceed 150 units in length. The arrival time at each node must meet its specified time window. Nodes [13, 23] must be on the same route. Nodes [5, 7] are priority points.",
        "code": "def check_constraints(solution: VrpState) -> bool:\n    # Vehicle Capacity Constraint - CVRP: The total load of each route must not exceed the vehicle capacity.\n    for route in solution.routes:\n        total_demand = sum(solution.problem_data[\"demand\"][node] for node in route)\n        if total_demand > solution.problem_data[\"capacity\"]:\n            return False\n\n    # Distance Limit Constraint - VRPL: Each route must not exceed 150 units in length.\n    max_route_length = 150\n    distances = solution.problem_data[\"edge_weight\"]\n\n    for route in solution.routes:\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n        route_length = sum(distances[tour[idx - 1]][tour[idx]] for idx in range(1, len(tour)))\n\n        # Check if the route length exceeds the maximum allowed length\n        if route_length > max_route_length:\n            return False\n\n    # Time Windows Constraint - VRPTW: The arrival time at each node must meet its specified time window.\n    for route in solution.routes:\n        current_time = 0\n        tour = [0] + route + [0]  # Add depot at the beginning and end of the route\n\n        for idx in range(1, len(tour)):\n            arrive_time = current_time + solution.problem_data['edge_weight'][tour[idx - 1]][tour[idx]]\n            wait_time = max(0, solution.problem_data['time_window'][tour[idx]][0] - arrive_time)  # Wait if early\n            current_time = arrive_time + wait_time\n\n            tw_start, tw_end = solution.problem_data['time_window'][tour[idx]]\n            if current_time > tw_end:\n                return False\n\n            # Add the service time for the current node after arriving and waiting\n            current_time += solution.problem_data['service_time'][tour[idx]]\n\n    # Same Vehicle Constraint - VRPSVC: Nodes [13, 23] must be on the same route.\n    for route in solution.routes:\n        if 13 in route and 23 in route:\n            break\n    else:\n        # If no route contains both nodes 13 and 23\n        return False\n\n    # Priority Constraint - PVRP: Nodes [5, 7] are priority points.\n    priority_levels = {\n        5: 1,  # Priority level 1 (highest priority)\n        7: 1,  # Priority level 1 (highest priority)\n    }\n    \n    # Default priority for non-listed nodes (lowest priority)\n    default_priority = 0\n\n    for route in solution.routes:\n        last_priority = max(priority_levels.values())  # Initialize to the highest priority\n\n        for node in route:\n            # Get current node's priority, using the default if not specified\n            current_priority = priority_levels.get(node, default_priority)\n\n            # If we encounter a node with higher priority than the last,\n            # the constraint is violated\n            if current_priority > last_priority:\n                return False\n\n            # Update the last seen priority\n            last_priority = current_priority\n\n    return True"
    }
]